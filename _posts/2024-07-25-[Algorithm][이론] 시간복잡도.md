---
title: "[Algorithm] 시간 복잡도"
excerpt: ""

categories:
  - ALGORITHM_STUDY
tags:
  - []
# toc(Table of Contents.) : true시 포스트의 목차가 보임.
toc: true
# true로 해주면 목차가 스크롤을 따라 움직이게 됨.
toc_sticky: true

# date : 글 처음 작성일
date: 2024-07-25
# last_modified_at : 글 마지막 수정일
last_modified_at: 2024-07-25
---

# 시간 복잡도

알고리즘에서 시간복잡도는 `연산 횟수`를 의미

일반적으로 `1초 = 1억 번` 의 연산을 의미

### 시간 복잡도 유형

**빅 오메가(Ω(n)) : 최선일 때(best case)의 연산 횟수를 나타낸 표기법**

**빅 세타(θ(n)) : 보통일 때(average case)의 연산 횟수를 나타낸 표기법**

**빅 오(O(n)) : 최악일 때(worst case)의 연산 횟수를 나타낸 표기법**

```java
public class timeComplexityExample1 {
	public static void main(String[] args){
		// 1~99 사이 값 랜덤 선택
		int findNumber = (int)(Math.random() * 100);
		for(int i=0; i<100; i++){
			if(i==findNumber){
				System.out.println(i);
				break;
			}
		}
	}
}
```

### 0~99 사이의 무작위 값을 찾는 위의 예시 코드를 기준으로 보는 시간 복잡도

- **빅 오메가(Ω(n))는 1 (바로 찾은 경우가 최선의 선택)**
- **빅 세타(θ(n))는 n/2 ( 최악과 최선의 중간)**
- **빅 오(O(n)) 는 n (맨 마지막에 찾은 경우)**

## 코딩 테스트에서 사용하는 시간 복잡도 유형

코딩 테스트에서는 빅-오(O(n))을 기준으로 수행 시간을 계산하는 것이 좋다

실제 코딩테스트에서는 1개의 테스트 케이스로 합격, 불합격을 결정하지 않고, 다양한 테스트 케이스로 테스트함으로 시간 복잡도를 판단할 때는 최악일 때(O(n))를 염두에 둬야 한다

### N의 크기에 따른 O(n)의 시간 복잡도

![alt text](/assets/img/timePro.png)

- **O(1)**: 상수 시간. 입력 크기와 관계없이 일정한 실행 시간을 가진다
- **O(log n)**: 로그 시간. 입력 크기의 로그에 비례하는 실행 시간을 가진다
- **O(n)**: 선형 시간. 입력 크기에 비례하는 실행 시간을 가진다
- **O(n log n)**: 선형로그 시간. 입력 크기의 로그에 비례하는 값과 곱으로 실행 시간을 가진다. 예를 들어, 많은 정렬 알고리즘이 이 시간 복잡도를 가진다
- **O(n^2)**, **O(n^3)** 등: 다항 시간. 입력 크기의 제곱, 세제곱 등으로 실행 시간이 증가한다
- **O(2^n)**: 지수 시간. 입력 크기의 지수에 비례하는 실행 시간을 가진다. 매우 큰 입력에 대해 비효율적이다
- **O(n!)**: 팩토리얼 시간. 입력 크기의 팩토리얼에 비례하는 실행 시간을 가진다. 매우 큰 입력에 대해 매우 느리다

O(n^2). 즉 다항 시간부터는 기하급수적으로 시간 복잡도가 증가하는 모습을 볼 수 있음

## 알고리즘 선택의 기준으로 사용

버블 정렬과 병합 정렬의 시간 복잡도가 각각 O(n^2), O(nlongn)임을 생각하고 문제 예시 진행

![alt text](/assets/img/timePro.png)
수 정렬하기 (https://www.acmicpc.net/problem/2750)

`시간 제한이 1초`이므로 이 조건을 만족하려면 `1억 번 이하의 연산 횟수`로 문제를 해결해야 함

- 연산 횟수는 1초에 1억 번 연산하는 것을 기준으로 생각
  - 연산 횟수 = 알고리즘 시간 복잡도 X 데이터의 크기
- 시간 복잡도는 항상 최악일 때, 즉 데이터의 크기가 가장 클 때를 기준으로 테스트

위 연산 횟수를 기준으로 계산을 해보면

- 버블 정렬 : O(n^2) = (1,000,000)^2 = 1,000,000,000,000 > 200,000,000 → 부적절
- 병합 정렬 : O(nlog(n)) = 1,000,000\*log(1,000,000) = 약 20,000,000 < 200,000,000 → 적절

위의 문제의 시간 제한은 2초이므로 2억 번의 연산 횟수 안에 답을 구해야 한다

버블 정렬은 약 10억 번의 연산 횟수가 필요하므로 이 문제를 풀기에 적합하지 못한 알고리즘임을 판단할 수 있다

반면, 병합 정렬은 약 2,000만 번의 연산 횟수로 답을 구할 수 있으므로 문제를 풀기에 적합한 알고리즘이라고 판단할 수 있다

### 시간 복잡도를 바탕으로 코드 로직 개선하기

시간 복잡도는 작성한 코드의 비효율적인 로직을 개선하는 바탕으로 사용할 수 있다

시간 복잡도를 활용하기 위해서는 시간 복잡도를 먼저 도출해야 한다

시간 복잡도를 도출하는 기준

1. 상수는 시간 복잡도 계산에서 제외
2. 가장 많이 중첩된 반복문의 수행 횟수가 시간 복잡도의 기준이 된다
   1. 한 코드에 O(n^2)의 반복문과 O(n)의 반복문이 존재한다면 O(n^2)을 기준으로 한다

```java
1. 상수는 시간 복잡도 계산에서 제외

// 연산 횟수가 N인 경우
public class 시간복잡도_판별원리1 {
	public static void main(String[] args){
		int N = 100000;
		int cnt = 0;
		for(int i=0; i < N; i++){
			System.out.println("연산 횟수:" + cnt++);
		}
	}
}

// 연산 횟수가 3N인 경우
public class 시간복잡도_판별원리2 {
	public static void main(String[] args){
		int N = 100000;
		int cnt = 0;
		for(int i=0; i < N; i++){
			System.out.println("연산 횟수:" + cnt++);
		}
		for(int i=0; i < N; i++){
			System.out.println("연산 횟수:" + cnt++);
		}
		for(int i=0; i < N; i++){
			System.out.println("연산 횟수:" + cnt++);
		}
	}
}
```

위에 두 예제 코드의 연산 횟수는 3배의 차이가 발생함

큰 차이처럼 느껴지지만 코딩 테스트에서는 일반적으로 상수를 무시하고 진행

따라서 두 코드 모두 시간 복잡도가 O(N)인 코드이다

```java
2. 가장 많이 중첩된 반복문의 수행 횟수가 시간 복잡도의 기준이 된다

public class 시간복잡도_판별원리3 {
	public static void main(String[] args){
		int N = 100000;
		int cnt = 0;
		for (int i = 0; i < N; i++){
			for(int j = 0; j < N; j++){
				System.out.println("연산 횟수:" + cnt);
			}
		}

		for(int j = 0; j < N; j++){
				System.out.println("연산 횟수:" + cnt);
		}
	}
}
```

위에 예제 코드에서 O(n^2)의 반복문과 O(n)의 반복문이 존재하고 있음

하지만 시간 복잡도는 가장 많이 중첩된 반복문을 기준으로 도출하므로 이 코드에서는 이중 for문이 전체 코드의 시간 복잡도의 기준이 된다

따라서 크기가 N인 반복문이 더 추가 되어도 이 코드의 시간 복잡도는 O(N^2)이다
