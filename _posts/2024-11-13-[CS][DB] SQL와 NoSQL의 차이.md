---
title: "[CS][DB] SQL과 NoSQL의 차이
excerpt: ""

categories:
  - CS_STUDY
tags:
  - [CS, 스터디, DB]
# toc(Table of Contents.) : true시 포스트의 목차가 보임.
toc: true
# true로 해주면 목차가 스크롤을 따라 움직이게 됨.
toc_sticky: true

# date : 글 처음 작성일
date: 2024-11-13
# last_modified_at : 글 마지막 수정일
last_modified_at: 2024-11-13
---

# SQL과 NoSQL의 차이

> Spring에서 ORM과 SQL Mapper 라이브러리인 JPA와 MyBatis 사용하며 항상 RDBMS인 MySQL과 MariaDB를 사용해 왔다. KB It's Your Life 교육 과정 중 마지막 프로젝트 발표 피드백에서 서비스에서 조회가 자주 일어나는 데 NoSQL을 사용해 성능을 높여보라는 권유를 받았고, NoSQL에 대해 알아보고 RDB와의 차이를 알아보고자 한다.

# DB와 Query Language
데이터베이스는 여러 사람이 공유하여 사용할 목적으로 체계화해 통합, 관리하는 데이터 집합이다  
쿼리 랭귀지는 DBMS에서 DB를 다루기 위해 사용되는 비절차적 언어이다.
> 비절차적 언어 : 원하는 결과에 대한 내용(what)만 명세하고 어떻게 결과를 얻는지에 대한 내용(how)이 없다
# DBMS(Data Base Management System)
![alt text](/assets/img/sql-image-4.png)

다수의 사용자들이 데이터베이스 내의 데이터에 접근할 수 있도록 해주는 소프트웨어 **도구의 집합**이다.  
사용자는 DB에 직접 요청을 보내는 게 아니라 DBMS에게 요청을 보내서 해당 DBMS가 DB에게 사용자의 요청을 전달하고, DB에서 전달받은 데이터를 사용자에게 넘겨준다.

# SQL(Structured Query Language)
![alt text](/assets/img/sql-image-7.png)

**RDBMS에서 사용되는 표준 질의언어**    
사용자는 SQL을 통해서 RDBMS에게 요청을 보내고, RDBMS는 사용자의 요청을 통해 DB에서 데이터를 꺼내서 사용자에게 테이블 형식으로 데이터를 보내준다.


# RDBMS(Relational Database Management System)의 특징
![alt text](/assets/img/sql-image-1.png)


## 1. 정해진 스키마에 따라 테이블 구성
![alt text](/assets/img/sql-image-3.png)

RDBMS는 관계형 데이터베이스로 데이터를 테이블 형식으로 저장하고 관리하는 방식이다.  
데이터의 관계를 테이블 간의 관계로 표현하고, 데이터는 행과 열로 구성된 구조화된 형태로 저장된다.

![alt text](/assets/img/sql-image-2.png)

RDB는 도서관을 예시로 볼 수 있다. 도서관에는 책장과 책 그리고 책을 찾을 수 있는 도서 검색 시스템이 있다. 이 상황을 예시로 RDB를 설명해보고자 한다.   
    


| RDB                       | 도서관                      |
|---------------------------|-----------------------------|
| 테이블 (Table)            | 책장                        |
| 행 (Row)                  | 책 한 권                    |
| 열 (Column)               | 책의 특정 섹션             |
| 관계 (Relationship)       | 카탈로그의 연결            |
| SQL                       | 도서 검색 시스템            |
| 데이터 무결성 유지        | 최신 도서 목록 유지         |


### 테이블(Table)
RDB는 데이터를 구조화하여 저장하는 기본 단위인 테이블 개념이 있다. 이는, 도서관의 책장과 책으로 이해할 수 있다. 예를 들어, 문학 책장에는 소설과 시, 철학 책장은 철학과 관련된 서적들이 모여 있는 것처럼, 하나의 테이블은 서로 관련된 데이터를 함께 저장하여 같은 종류의 정보를 모아두는 역할을 한다.

### 행(Row)
테이블의 각 행을 레코드라고도 하며, 개별적인 데이터를 나타낸다.  
책장은 많은 책들로 이루어져 있으며, 한 권 한 권이 독립된 정보를 담고 있다. 마찬가지로 RDB에서 행은 하나의 데이터 단위이다. 예를 들어, 학생 정보를 저장하는 테이블이라면 각 행이 학생 한 명에 대한 정보를 가지고 있는 것이다.

### 열(Column)
테이블의 각 열은 속성, 필드라고도 하며, 해당 테이블에 저장되는 데이터의 특성을 정의한다. 책장에 있는 각각의 책들은 책의 표지나 출판사, 저자 등 책에 기록된 다양한 정보를 한 권의 책에서 다양한 세부 정보로 구성된다. 데이터베이스에서 열은 이러한 정보의 세부 항목으로, 학생 정보라면 이름, 학번, 전공과 같은 속성들을 나타낸다.  

### 관계(Relationship)
도서관에는 특정 도서의 위치를 알려주는 카탈로그가 있어, 원하는 책의 서가를 찾을 수 있다. 예를 들어, ‘저자’를 기준으로 다른 책장에 있는 여러 책이 서로 연결될 수 있다. 이처럼 RDB에서도 외래 키를 통해 다른 테이블과 관계를 설정하여 데이터를 연결할 수 있다. 하나의 테이블에서 특정 데이터가 다른 테이블에 어떻게 연결되는지를 보여줄 수 있는 것이다.

### SQL
도서관의 검색 시스템을 통해 특정 주제, 저자, 출판 연도 등을 입력하여 원하는 책을 찾을 수 있는 것처럼, RDB에서는 SQL을 통해 원하는 조건에 맞는 데이터를 빠르게 조회할 수 있다. 검색 시스템이 복잡한 요구사항에도 정확한 책을 찾아주는 것처럼, SQL은 다양한 조건을 통해 원하는 데이터를 추출할 수 있게 해준다.


### 데이터 무결성 유지
도서관에서 책이 대출되거나 반납되면 목록을 업데이트하여 최신 상태로 유지하는 것처럼, RDB도 데이터의 무결성을 유지하며 최신 데이터를 관리한다. 책장에 특정 책이 중복되거나 잘못 분류되지 않도록 관리하듯이, 데이터베이스에서도 중복을 최소화하고 데이터를 일관성 있게 관리한다.

이런 관계형 데이터베이스는 일반적으로 서비스에서 가장 많이 사용되는 DB 타입이다. 회원정보나 게시글 정보 등 정해진 데이터 타입에 따라 데이터가 추가되거나 삭제되는 방식이기에 복잡한 계산 없이 데이터가 어디로 들어가야 할지 미리 정해져 있는 경우가 대부분이다. 따라서, 추가되는 정보가 숫자인지 문자인지 미리 정해둘 수 있어서 효율적인 DB설계가 가능하다. 관계형 데이터베이스는 과거부터 오랫동안 사용되어 왔고, 수백만 건의 데이터들 중에서 원하는 내용을 찾고, 미리 예상되는 데이터의 흐름에 맞게 설계해두기 때문에, 안정성도 높다.

## 2. 테이블끼리 관계를 가진다
### 1:1 관계
![alt text](/assets/img/sql-image-5.png)
- 하나의 레코드가 다른 테이블의 레코드 한 개와 연결된 경우
- 1:1 관계는 잘 사용되지 않는다. phone_number라는 컬럼을 Users테이블에 추가하면 되기 때문
 
### 1:N 관계
![alt text](/assets/img/sql-image-6.png)
- 하나의 레코드가 서로 다른 여러 개의 레코드와 연결된 경우
- 한 명의 유저가 여러 전화번호를 가지는 상황
- 1:N 관계가 관계형 데이터베이스에서 가장 많이 사용됨

### N:M 관계
![alt text](/assets/img/sql-image-9.png)
- 여러 개의 레코드가 다른 테이블의 여러 개의 레코드와 관계가 있는 경우
- 여러 개의 여행 상품이 있고, 여러 명의 고객이 있는 상황

![alt text](/assets/img/sql-image-8.png)
- 다대다 관계는 조인 테이블을 사용하여 두 개의 일대다 관계로 만든다
- customer_package 테이블에서는 고객 한 명이 여러 개의 여행 상품을 가질 수 있고, 여행 상품 하나가 여러 개의 고객을 가질 수 있다


## 3. Transaction을 사용한다
Transaction은 데이터베이스의 상태를 변화시키기 위해서 수행하는 **논리적 작업 단위**이며 아래의 특징을 가진다

### 원자성(Atomicity)
트랜잭션은 **모두 수행**되거나 **모두 수행되지 않게** 보장한다  
> 단 하나의 작업이라도 실패하면 전체를 롤백하여 원자성을 보장한다

### 일관성(Consistency)
트랜잭션이 일어난 이후에도 데이터베이스의 전체적인 데이터들이 데이터베이스의 제약이나 규칙을 만족한다

### 격리성(Isolation)
트랜잭션 수행 중에 다른 트랜잭션의 작업이 끼어들지 못한다  
**트랜잭션 간에는 서로 독립적으로 수행된다**  
ISOLATION LEVEL(격리 레벨)  
1. READ UNCOMMITTED (가장 낮은 수준)
- 트랜잭션이 커밋되지 않은 다른 트랜잭션의 변경 내용도 읽을 수 있다
2. READ COMMITTED
- 트랜잭션이 커밋된 데이터만 읽을 수 있다
3. REPEAT TABLE READ(MySQL Default)
- 트랜잭션이 시작된 후 다른 트랜잭션이 해당 데이터를 변경하는 것을 막기 위해 내가 읽은 데이터를 잠궈서 다른 트랜잭션이 수정할 수 없게 만든다
4. SERIALIZABLE (가장 높은 격리 수준)
- 모든 데이터를 잠궈서 다른 트랜잭션이 해당 데이터에 접근하는 것을 막음. 동시성 처리 속도는 낮아지지만, 데이터의 일관성과 무관성이 보장됨

### 지속성(Durability)
트랜잭션 성공시 적용된 결과는 영구적으로 지속된다   
시스템이 다운되거나, 기타 문제가 발생해도 트랜잭션 결과는 유지된다

## 4. Index
테이블에 대한 **검색 속도**를 높여주는 자료 구조(책의 목차 역할)  
테이블 내에 1개의 컬럼, 또는 여러 개의 컬럼을 이용하여 생성하고 사용


# NoSQL

## 등장배경
- 트랜잭션을 통한 안정적인 데이터 관리가 가장 중요했기에 RDBMS만 사용했었음
- 사용자의 급격한 증가로 인해 데이터를 단일 서버에 모두 넣을 수 없는 문제가 발생
- 서버의 확장이 불가피한데 서버 한 대에서 실행되도록 설계된 관계형 데이터베이스를 위한 수직적 확장의 가격이 비쌈
- RDBMS의 한계인 수평적 확장을 위해 NoSQL 데이터베이스가 등장함 
- NoSQL은 데이터의 일관성을 약간 포기한 대신 여러 대의 컴퓨터에 데이터를 분산하여 저장하는 것을 목표로 함

## 특징
### 1. 유연한 데이터 모델
RDBMS와 달리 고정된 스키마가 없다  
즉, 데이터를 **유연하게** 추가, 삭제, 수정 가능  
따라서, 데이터 모델의 **변화**에 대한 대응이 용이함

EX) 사용자 정보에 주소지가 필요하지 않던 서비스가 확장되면서 주소지를 추가해야 하는 상황이 발생할 경우, RDBMS에서는 주소지 컬럼을 테이블에 추가해야 한다. 반면, NoSQL은 유연한 데이터 모델의 변화를 가지고 있어 구조 변경에 대한 비용이 적게 든다.
```JSON
// Before
{
  "이름": "홍길동",
  "나이": 23,
}

// After
{
  "이름": "홍길동",
  "나이": 23,
  "주소": "서울시"
}
```
또한, RDBMS의 경우 데이터를 테이블에 맞게 쪼개서 저장해야 하기에 어플리케이션단에서 데이터 구조에 맞게 매핑 해줘야 했지만, NoSQL에서는 이러한 노력이 필요 없어짐. 따라서, 서비 로직이 간단해질 수 있음

## 데이터 모델 종류
![alt text](/assets/img/sql-image-12.png)
### Column (컬럼 기반 데이터 모델) (Apache Cassandra, HBase)
![alt text](/assets/img/sql-image-10.png)
  - Ring 구조 분산 저장 방식
  - 각 노드(A,B,C,..)는 분산된 클러스터 내의 독립적인 서버이며, 데이터는 각 노드에 분산되어 저장됨
  - 해시 함수를 사용하여 Row Key가 특정 범위에 매핑되도록 하여 데이터를 분산시킴
  - 특정 노드가 장애를 일으켜도 다른 노드가 데이터를 백업하고 있어서 고가용성을 보장함
  
| Row Key (User ID) | Column Name       | Column Value          |
|--------------------|-------------------|------------------------|
| user123           | 이름              | 홍길동                |
|                   | 나이              | 30                    |
|                   | 이메일            | hong@example.com      |
|                   | 전화번호           | 010-1234-5678         |
| user456           | 이름              | 김철수                |
|                   | 나이              | 25                    |
|                   | 이메일            | kim@example.com       |
|                   | 주소              | 서울특별시 강남구      |
| user789           | 이름              | 이영희                |
|                   | 이메일            | lee@example.com       |
  - Row Key를 통해 각 사용자의 데이터를 빠르게 조회 가능
  - Column Name은 데이터 항목의 이름, Column Value는 실제 데이터 값이 저장


  - 장점
    - DB를 분산화하여 여러 인스턴스에서 구동 가능하지만, 사용자에게는 하나의 DB처럼 조작 가능 제공
    - 매우 빠른 Read와 Write 연산
  - 단점
    - Column형 데이터베이스이기 때문에 기존 Row형 RDB와 달리 진입장벽이 높다
    - 복잡한 Query가 불가능하다

  
### Graph (그래프 기반 ) (Neo4j)
 node 간의 연관관계(친구의 친구의 친구를 조회하는 등과 같은 작업)를 표현하는 데 있어서 효율적인 처리가 가능한 모델 구조  
 ![alt text](/assets/img/sql-image-11.png)
- 노드
  - 그래프를 이루는 기본 단위
  - 관계를 통해 다른 노드에 연결되고 하나 이상의 속성과 관계를 가질 수 있음
- 관계 
  - 노드와 노드 사이의 관계를 의미
  - 관계는 단방향
  - 하나 이상의 속성을 가질 수 있음
- 레이블
  - 노드를 카테고리화 하기 위해서 사용
  - 레이블에는 속성이 없음
- 속성 : 노드나 관계에 저장하고 싶은 데이터를 Key-Value 형태로 저장

Ex) 소셜 네트워크에서의 친구 관계  
- 노드 : 사용자A, 사용자B  
- 엣지 : 친구 관계(A->B)  
- 속성 : 각 사용자 노드에 들어갈 이름, 나이 등의 속성과 친구 관계를 나타내는 엣지에 들어갈 친구가 된 날짜 같은 속성 정보
- 위와 같이 데이터 베이스가 구현되면 "사용자A와 2단계 이내에 연결된 모든 친구"와 같은 복잡한 관계 기반 쿼리를 효율적으로 처리할 수 있다


### Key-Value ( Redis )
데이터를 메모리에 저장하는 인메모리(In-memory)방식으로 동작하여 빠른 데이터 접근을 지원하고, 주로 캐시, 세션 관리, 실시간 데이터 분석 등에 활용됨

#### redis를 활용한 키-값 저장소 활용
```JAVA
// Entity
@RedisHash("User")  // Redis에 저장할 해시 이름
public class User implements Serializable {
    @Id
    private String id;
    private String name;
    private int age;
}

// repository
public interface UserRepository extends CrudRepository<User, String> {
    // 기본 CRUD 메서드가 자동 생성됨
}

@Service
public class UserService {

    private final UserRepository userRepository;

    // 사용자 정보 저장
    public User saveUser(User user) {
        return userRepository.save(user);
    }

    // 사용자 정보 조회
    public Optional<User> getUserById(String id) {
        return userRepository.findById(id);
    }

    // 사용자 삭제
    public void deleteUser(String id) {
        userRepository.deleteById(id);
    }
}
```
단순한 CRUD 작업이 필요하고 Redis를 키-값 저장소만으로 활용할 경우 CrudRepository가 적합하고, 만료 시간 설정, 해시 조작 등 기능을 사용할 경우 RedisTemplate를 사용하는 것이 좋음

### Document (문서 지향 데이터베이스) (MongoDB)
MongoDB는 고성능, 고가용성 및 쉬운 확장성을 제공하는 NoSQL이며 Document 지향 데이터베이스이다  
![alt text](image-13.png)
데이터를 배열이나 중첩 Document와 같은 복잡한 데이터 유형을 효율적으로 저장할 수 있는 유연한 JSON과 유사한 형식인 BSON(Binary JSON)으로 저장한다  
> Binary JSON : JSON은 사람이 읽기 편하지만, BSON은 이진 형식으로 사람이 읽기 어려운 반면 텍스트 형식보다 적은 용량을 사용하며, 처리 속도가 빠름  

RDBMS에서 테이블에 해당하는 개념을 **collection**이라고 하며, 컬랙션에 여러 개의 문서가 저장되는 구조
```JSON
// Create
db.users.insertOne({   "name": "John Doe",   "email": "john.doe@example.com" })`

// Read
db.users.find({"age": {"$gt": 30}})`

// Update
db.users.updateOne({"_id": ObjectId("507f1f77bcf86cd799439011")}, {"$set": {"email": "new.email@example.com"}})

// Delete
db.users.deleteOne({"_id": ObjectId("507f1f77bcf86cd799439011")})
```

### 2. 저렴한 비용
- 오픈소스 제품들이 많아서 비교적 저렴하고, 무료로 사용할 수 있는 제품도 많다
- 수직적 확장(Scale-Up)이 아닌 노드(서버)를 추가하는 수평적 확장(Scale-Out)이 가능하여 확장 비용이 비교적 저렴

### 3. 분산 시스템
![alt text](/assets/img/sql-image-14.png)

데이터를 여러 노드에 분산하여 저장하고 처리하는 시스템  
새로운 노드를 추가하는 Scale-out에 용이하고, 노드 하나가 다운되어도 시스템 전체가 중단되지 않도록 하여 시스템 가용성이 높다

#### 분산 시스템 설계 원칙(CAP)
![alt text](/assets/img/sql-image-15.png)
##### Consistency (일관성)
- 모든 클라이언트는 같은 시간에 같은 데이터를 볼 수 있어야 한다
##### Availability (가용성)
- 노드 중 하나 이상의 노드가 실패하더라도 정상적으로 요청을 처리할 수 있어야 한다
  - 데이터 복제를 통해 여러 노드에 복사하여 저장하는 방식이기에 특정 노드가 실패해도 다른 노드가 데이터를 제공할 수 있다
##### Partition tolerance (장애 내성)
- Partition (네트워크 개념의 partition): 분산 시스템에서 노드 간 통신이 일시적으로 불가능 해지는 상황 
- 서버 다운과 같은 분할 상황이 발생하더라도 시스템 전체가 작동해야 한다

#### CA : P(장애 내셩)을 고려하지 않는 분류
노드 간 통신이 일시적으로 중단되면 시스템 전체가 다운  
#### CP : A(가용성)을 고려하지 않는 분류
대표적으로 MongoDB가 여기에 해당  
MongoDB는 프라이머리 노드에서 모든 데이터에 대한 권한을 가지고 있고, 세컨더리 노드는 이 프라이머리 노드의 트랜잭션 로그를 활용해서 똑같은 데이터를 가지고 있음  
P(장애 내성)의 경우 프라이머리 노드에서 장애가 발생하면 프라이머리 노드가 내려가고 세컨더리 노드가 올라와서 복구됨(잠깐이지만 가용성이 포기됨)  
또한, 프라이머리 노드만 데이터 권한을 가지고 있기 때문에 모든 클라이언트는 같은 시간에 같은 데이터를 볼 수 있는 C(일관성)도 보장되어 CP에 해당됨
#### AP : C(일관성)을 고려하지 않는 분류 (동기화에 시간이 필요)
가용성을 가지려면 노드 중 하나 이상의 노드가 실패하더라도 정상적으로 요청을 처리해야 함. 이는 각 노드가 자기 데이터에 대한 권한이 있어야 함. 따라서, 자신의 데이터가 변경되면 다른 노드와의 통신을 통해서 동기화 해야 함. 이때, 동기화가 되는 시간에서 모든 클라이언트가 같은 시간에 데이터를 볼 수 있어야하는 C(일관성)이 보장되지 못한다


#### PACELC (PAC + ELC)
![alt text](/assets/img/sql-image-16.png)

PAC : 분할장애시 AP 또는 CP선택  
ELC : 정상적인 상황에서 어떤 것에 더 중점을 두느냐


CA의 경우 분산 시스템에서 장애가 생기면 시스템이 다운되는 문제가 생겨서 이를 해결하고자 PACELC 설계 원칙이 생김  
장애와 정상작동(ELSE)로 나누어 진행  

- 장애 : 가용성과 일관성 중 하나를 고름 (CP or AP)
- 정상작동 : Latency와 Consistency 중에 고름
  - Consistency : 같은 시간에 같은 데이터를 볼 수 있어야 한다
    - 모든 노드가 최신 상태의 데이터를 유지할 수 있도록 노드 간 동기화를  완료한 후 응답을 반환
  - Latency : 시간 지연을 줄여서 빠른 응답을 보장
    - 일부 노드가 업데이트 되기 전에 응답을 반환하여 빠르지만, 업데이트가 반영되지 않은 노드로부터 데이터를 조회할 경우 일관성이 깨질 수 있음  
    쇼핑 시스템에서 장바구니 담기가 A노드에 처리되었을 때, B,C노드로 전파되기 전에 사용자의 장바구니 조회 요청이 B노드로 향하면 이전 장바구니 정보가 올 수 있다
> 보기에는 Latency가 더 오래 걸릴 거 같지만 Consistency는 노드끼리 모두 통신이 되어야하고 같은 데이터가 있는지도 확인을 해야 보장 가능하기에 Latency가 조금 더 빠르다

### 4. BASE
분산 시스템의 특징인 BASE는 데이터 일관성을 유지하고 시스템 가용성을 유지한다

#### BA(Basically Available) (기본적 가용성)
- 데이터베이스가 일부 노드에서 실패하더라도 적절한 레플리케이션과 분산 시스템을 사용하여 전체적인 시스템의 가용성을 유지한다
- 일부 노드에서 데이터베이스 서비스가 중단되어도 다른 노드에서는 계속하여 서비스를 제공한다

#### S(Soft State)
- 분산 시스템에서 발생하는 네트워크 지연, 노드 간 통신 문제로 인해 데이터베이스의 상태는 시간에 따라 변할 수 있다
- 데이터 베이스가 능동적으로 상태를 조정하여 데이터 일관성을 유지한다

#### E (Eventually Consistent)
- C(일관성)과 비슷한 개념으로, 데이터 일관성이 모든 노드에서 즉시 유지되지 않을 수 있지만 일정 시간 이내에 결국 데이터 일관성이 유지된다.


# 결론
RDBMS는 고정된 스키마와 강력한 데이터 일관성을 제공하는 특징이 있어, 복잡한 관계형 데이터를 구조화하고 관리하기에 적합한 반면, NoSQL은 유연한 스키마와 높은 수평 확장성을 통해 비정형 데이터와 대용량 실시간 데이터 처리에 뛰어난 특징이 있다.  
서버의 수평 확장과 빠른 속도가 장점인 NoSQL이 나왔음에도 안정성, 복잡한 쿼리 처리, 트랜잭션 일관성에서면에서 RDBMS를 사용한다.  
결국, 사용자는 자신의 서비스 목적에 따라 RDBMS와 NoSQL의 장단점을 고려하여 상황에 맞는 데이터베이스를 선택하고 데이터 모델을 선택하여 활용하면 된다.  
